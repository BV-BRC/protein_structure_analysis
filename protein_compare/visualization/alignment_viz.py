"""Alignment visualization and PyMOL script generation.

Provides visualization of aligned protein structures with
coloring by RMSD, pLDDT, or divergence regions.
"""

from pathlib import Path
from typing import Literal, Optional

import numpy as np
import matplotlib.pyplot as plt

from protein_compare.io.parser import ProteinStructure
from protein_compare.core.alignment import AlignmentResult


class AlignmentVisualizer:
    """Visualize aligned protein structures."""

    # Color schemes
    RMSD_CMAP = "RdYlGn_r"  # Red = high RMSD, Green = low
    PLDDT_CMAP = "RdYlBu"    # Red = low, Blue = high confidence

    def __init__(self):
        """Initialize the visualizer."""
        pass

    def generate_pymol_script(
        self,
        struct1: ProteinStructure,
        struct2: ProteinStructure,
        alignment: AlignmentResult,
        color_by: Literal["rmsd", "plddt", "chain"] = "rmsd",
        output_path: Optional[str | Path] = None,
    ) -> str:
        """Generate PyMOL script for visualizing aligned structures.

        Args:
            struct1: First protein structure.
            struct2: Second protein structure.
            alignment: AlignmentResult from structural alignment.
            color_by: Coloring scheme (rmsd, plddt, or chain).
            output_path: Optional path to save script.

        Returns:
            PyMOL script as string.
        """
        script_lines = [
            "# PyMOL script for aligned structure visualization",
            "# Generated by protein_compare",
            "",
            "# Load structures",
            f'cmd.load("{struct1.name}.pdb", "{struct1.name}")',
            f'cmd.load("{struct2.name}.pdb", "{struct2.name}")',
            "",
            "# Apply transformation to structure 2",
            "import numpy as np",
            f"rotation = {alignment.rotation_matrix.tolist()}",
            f"translation = {alignment.translation_vector.tolist()}",
            "",
            "# Transform structure 2",
            f'cmd.transform_selection("{struct2.name}", [\\',
        ]

        # Build 4x4 transformation matrix for PyMOL
        rot = alignment.rotation_matrix
        trans = alignment.translation_vector
        script_lines.append(
            f"    {rot[0,0]}, {rot[0,1]}, {rot[0,2]}, {trans[0]},"
        )
        script_lines.append(
            f"    {rot[1,0]}, {rot[1,1]}, {rot[1,2]}, {trans[1]},"
        )
        script_lines.append(
            f"    {rot[2,0]}, {rot[2,1]}, {rot[2,2]}, {trans[2]},"
        )
        script_lines.append("    0, 0, 0, 1])")
        script_lines.append("")

        if color_by == "rmsd":
            script_lines.extend(self._color_by_rmsd_script(
                struct1.name, struct2.name, alignment
            ))
        elif color_by == "plddt":
            script_lines.extend(self._color_by_plddt_script(
                struct1, struct2
            ))
        else:  # chain
            script_lines.extend([
                "# Color by chain",
                f'cmd.color("green", "{struct1.name}")',
                f'cmd.color("cyan", "{struct2.name}")',
            ])

        script_lines.extend([
            "",
            "# Display settings",
            "cmd.show_as('cartoon')",
            "cmd.set('cartoon_transparency', 0.3)",
            "cmd.bg_color('white')",
            "cmd.set('ray_opaque_background', 1)",
            "",
            "# Center view",
            "cmd.zoom('all')",
            "",
            f"# RMSD: {alignment.rmsd:.2f} Angstroms",
            f"# TM-score: {alignment.tm_score:.3f}",
        ])

        script = "\n".join(script_lines)

        if output_path:
            Path(output_path).write_text(script)

        return script

    def _color_by_rmsd_script(
        self,
        name1: str,
        name2: str,
        alignment: AlignmentResult,
    ) -> list[str]:
        """Generate PyMOL commands for RMSD coloring.

        Args:
            name1: Name of structure 1.
            name2: Name of structure 2.
            alignment: AlignmentResult.

        Returns:
            List of PyMOL commands.
        """
        lines = [
            "# Color by per-residue RMSD",
            "cmd.set_color('low_rmsd', [0.0, 0.8, 0.0])   # Green",
            "cmd.set_color('mid_rmsd', [1.0, 1.0, 0.0])   # Yellow",
            "cmd.set_color('high_rmsd', [1.0, 0.0, 0.0])  # Red",
            "",
        ]

        # Color residues based on RMSD
        for (i, j), dist in zip(alignment.residue_mapping, alignment.per_residue_distance):
            if dist < 1.0:
                color = "low_rmsd"
            elif dist < 3.0:
                color = "mid_rmsd"
            else:
                color = "high_rmsd"

            lines.append(f'cmd.color("{color}", "{name1} and resi {i+1}")')
            lines.append(f'cmd.color("{color}", "{name2} and resi {j+1}")')

        return lines

    def _color_by_plddt_script(
        self,
        struct1: ProteinStructure,
        struct2: ProteinStructure,
    ) -> list[str]:
        """Generate PyMOL commands for pLDDT coloring.

        Uses AlphaFold color scheme:
        - Blue: >90 (very high)
        - Cyan: 70-90 (confident)
        - Yellow: 50-70 (low)
        - Orange: <50 (very low)
        """
        lines = [
            "# Color by pLDDT confidence",
            "cmd.set_color('plddt_vh', [0.0, 0.3, 0.8])   # Very high (>90)",
            "cmd.set_color('plddt_h', [0.3, 0.8, 0.9])    # High (70-90)",
            "cmd.set_color('plddt_l', [1.0, 0.85, 0.0])   # Low (50-70)",
            "cmd.set_color('plddt_vl', [1.0, 0.5, 0.0])   # Very low (<50)",
            "",
        ]

        for struct in [struct1, struct2]:
            for i, plddt in enumerate(struct.plddt):
                if plddt >= 90:
                    color = "plddt_vh"
                elif plddt >= 70:
                    color = "plddt_h"
                elif plddt >= 50:
                    color = "plddt_l"
                else:
                    color = "plddt_vl"

                lines.append(f'cmd.color("{color}", "{struct.name} and resi {i+1}")')

        return lines

    def save_aligned_pdb(
        self,
        structure: ProteinStructure,
        alignment: AlignmentResult,
        output_path: str | Path,
        apply_transform: bool = True,
    ) -> None:
        """Save structure with alignment transformation applied.

        Args:
            structure: ProteinStructure to save.
            alignment: AlignmentResult with transformation.
            output_path: Path for output PDB.
            apply_transform: Whether to apply transformation.
        """
        if structure.biopython_structure is None:
            raise ValueError("Structure must have BioPython structure attached")

        from Bio.PDB import PDBIO

        if apply_transform:
            # Apply transformation to all atoms
            for atom in structure.biopython_structure.get_atoms():
                coord = atom.get_coord()
                new_coord = coord @ alignment.rotation_matrix.T + alignment.translation_vector
                atom.set_coord(new_coord)

        io = PDBIO()
        io.set_structure(structure.biopython_structure)
        io.save(str(output_path))

    def divergence_plot(
        self,
        alignment: AlignmentResult,
        plddt1: Optional[np.ndarray] = None,
        plddt2: Optional[np.ndarray] = None,
        figsize: tuple[int, int] = (12, 6),
    ) -> plt.Figure:
        """Create divergence plot showing per-residue RMSD and confidence.

        Args:
            alignment: AlignmentResult.
            plddt1: Optional pLDDT for structure 1.
            plddt2: Optional pLDDT for structure 2.
            figsize: Figure size.

        Returns:
            Matplotlib Figure.
        """
        fig, axes = plt.subplots(2, 1, figsize=figsize, sharex=True)

        residue_positions = range(len(alignment.per_residue_distance))

        # Top: Per-residue distance
        ax1 = axes[0]
        colors = ['green' if d < 1 else 'orange' if d < 3 else 'red'
                  for d in alignment.per_residue_distance]
        ax1.bar(residue_positions, alignment.per_residue_distance, color=colors, width=1.0)
        ax1.axhline(y=1.0, color='gray', linestyle='--', alpha=0.5, label='1A')
        ax1.axhline(y=3.0, color='gray', linestyle=':', alpha=0.5, label='3A')
        ax1.set_ylabel('Per-residue distance (A)')
        ax1.set_title(f'Structural Divergence (RMSD={alignment.rmsd:.2f}A, TM-score={alignment.tm_score:.3f})')
        ax1.legend(loc='upper right')

        # Bottom: pLDDT scores if provided
        ax2 = axes[1]
        if plddt1 is not None and plddt2 is not None:
            idx1 = [m[0] for m in alignment.residue_mapping]
            idx2 = [m[1] for m in alignment.residue_mapping]
            p1 = plddt1[idx1]
            p2 = plddt2[idx2]

            ax2.fill_between(residue_positions, 0, p1, alpha=0.5, label='Structure 1')
            ax2.fill_between(residue_positions, 0, p2, alpha=0.5, label='Structure 2')
            ax2.axhline(y=70, color='gray', linestyle='--', alpha=0.5)
            ax2.axhline(y=50, color='gray', linestyle=':', alpha=0.5)
            ax2.set_ylabel('pLDDT')
            ax2.set_ylim(0, 100)
            ax2.legend(loc='lower right')
        else:
            ax2.text(0.5, 0.5, 'No confidence scores available',
                    ha='center', va='center', transform=ax2.transAxes)

        ax2.set_xlabel('Aligned residue position')

        plt.tight_layout()
        return fig

    def superposition_quality_plot(
        self,
        alignment: AlignmentResult,
        figsize: tuple[int, int] = (8, 6),
    ) -> plt.Figure:
        """Create plot showing alignment quality metrics.

        Args:
            alignment: AlignmentResult.
            figsize: Figure size.

        Returns:
            Matplotlib Figure.
        """
        fig, ax = plt.subplots(figsize=figsize)

        # Cumulative distribution of distances
        sorted_dist = np.sort(alignment.per_residue_distance)
        cumulative = np.arange(1, len(sorted_dist) + 1) / len(sorted_dist)

        ax.plot(sorted_dist, cumulative * 100, 'b-', linewidth=2)
        ax.axvline(x=1.0, color='green', linestyle='--', alpha=0.7, label='1A')
        ax.axvline(x=2.0, color='orange', linestyle='--', alpha=0.7, label='2A')
        ax.axvline(x=4.0, color='red', linestyle='--', alpha=0.7, label='4A')

        # Mark GDT thresholds
        for thresh in [1, 2, 4, 8]:
            pct = np.sum(sorted_dist <= thresh) / len(sorted_dist) * 100
            ax.scatter([thresh], [pct], s=100, zorder=5)
            ax.annotate(f'{pct:.0f}%', (thresh, pct), textcoords="offset points",
                       xytext=(5, 5), fontsize=10)

        ax.set_xlabel('Distance threshold (A)')
        ax.set_ylabel('% Residues within threshold')
        ax.set_title('Cumulative Distance Distribution')
        ax.set_xlim(0, max(10, sorted_dist[-1] * 1.1))
        ax.set_ylim(0, 105)
        ax.legend()
        ax.grid(True, alpha=0.3)

        return fig
